from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
import json
import re
import requests
from bs4 import BeautifulSoup
from datetime import datetime, timedelta
import os
import sqlite3

# ------------------------------------------------------
# PATHS
# ------------------------------------------------------
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DB_PATH = os.path.join(BASE_DIR, "history.db")
DECKS_PATH = os.path.join(BASE_DIR, "all_decks_by_region_and_set.json")
CACHE_FILE = os.path.join(BASE_DIR, "price_cache.json")

# Static Collectr data (generated by Playwright)
DATA_DIR = os.path.join(BASE_DIR, "data")
DONS_FILE = os.path.join(DATA_DIR, "dons_collectr.json")
SEALED_FILE = os.path.join(DATA_DIR, "sealed_collectr.json")

# ------------------------------------------------------
# CARD PRICE CACHE (Limitless)
# ------------------------------------------------------
PRICE_CACHE = {}
CACHE_TTL = timedelta(hours=24)

if os.path.exists(CACHE_FILE):
    try:
        with open(CACHE_FILE, "r", encoding="utf-8") as f:
            raw = json.load(f)
            for key, val in raw.items():
                PRICE_CACHE[key] = {
                    "timestamp": datetime.fromisoformat(val["timestamp"]),
                    "data": val["data"],
                }
        print("Loaded card price cache:", len(PRICE_CACHE))
    except Exception as e:
        print("Failed to load card cache:", e)


def save_cache_to_disk():
    try:
        serializable = {
            k: {
                "timestamp": v["timestamp"].isoformat(),
                "data": v["data"],
            }
            for k, v in PRICE_CACHE.items()
        }
        with open(CACHE_FILE, "w", encoding="utf-8") as f:
            json.dump(serializable, f)
    except Exception as e:
        print("Failed to save cache:", e)

# ------------------------------------------------------
# FASTAPI APP
# ------------------------------------------------------
app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# ------------------------------------------------------
# HELPERS
# ------------------------------------------------------
def parse_price(text: str) -> float:
    if not text:
        return 0.0

    m = re.search(r"([\d\.,]+)", text.replace("\u00a0", " ").strip())
    if not m:
        return 0.0

    s = m.group(1)

    if "," in s and "." in s:
        s = s.replace(",", "")
    elif "," in s and "." not in s:
        s = s.replace(",", ".")

    try:
        return float(s)
    except Exception:
        return 0.0


def file_mtime_iso(path: str):
    try:
        return datetime.utcfromtimestamp(os.path.getmtime(path)).isoformat()
    except Exception:
        return None


def load_collectr_items(path: str, prefix: str):
    """
    Loads Collectr prices from JSON generated by Playwright.

    Supports BOTH formats:
    A) dict:
       {"don::NAME": {"usd": 1.2, "eur": 0.9, "image_url": "..."}}
    B) list:
       [{"name": "...", "price_usd": 1.2, "price_eur": 0.9, ...}]
    Returns list of:
      {name, usd_price, eur_price, image_url, source}
    """
    if not os.path.exists(path):
        return []

    with open(path, "r", encoding="utf-8") as f:
        raw = json.load(f)

    items = []

    # Format A: dict keyed by "don::Name" / "sealed::Name"
    if isinstance(raw, dict):
        for k, v in raw.items():
            if not isinstance(v, dict):
                continue

            name = k
            if isinstance(k, str) and k.startswith(prefix + "::"):
                name = k.split("::", 1)[1]

            usd = v.get("usd", v.get("usd_price", 0)) or 0
            eur = v.get("eur", v.get("eur_price", 0)) or 0

            items.append({
                "name": name,
                "usd_price": float(usd) if usd is not None else 0.0,
                "eur_price": float(eur) if eur is not None else 0.0,
                "image_url": v.get("image_url"),
                "source": v.get("source", "collectr"),
            })

        return items

    # Format B: list of dicts
    if isinstance(raw, list):
        for it in raw:
            if not isinstance(it, dict):
                continue

            name = it.get("name")
            if not name:
                continue

            usd = it.get("price_usd", it.get("usd_price", it.get("usd", 0))) or 0
            eur = it.get("price_eur", it.get("eur_price", it.get("eur", 0))) or 0

            items.append({
                "name": name,
                "usd_price": float(usd) if usd is not None else 0.0,
                "eur_price": float(eur) if eur is not None else 0.0,
                "image_url": it.get("image_url"),
                "source": it.get("source", "collectr"),
            })

    return items


# ------------------------------------------------------
# LIMITLESS SCRAPER (CARDS + PROMOS)
# ------------------------------------------------------
BASE_URL = "https://onepiece.limitlesstcg.com/cards/{}"

# Normal set cards: OP01-001, ST10-012, EB01-003 ...
NORMAL_ID_RE = re.compile(r"^[A-Z]+[0-9]{2}-[0-9]{3}$")
# Promo cards: P-001, P-012, P-045
PROMO_ID_RE = re.compile(r"^P-[0-9]{3}$")

# Accept legacy embedded versions too (OP01-001?v=1, OP01-001V=1, etc.)
EMBEDDED_V_RE = re.compile(r"(?:\?|&)?V=(\d+)", re.IGNORECASE)


def normalize_card_and_version(card_id_raw: str, v_query: int | None):
    """
    Returns (base_id, version_int).
    Supports:
      - /price/OP01-001?v=2        (v_query=2)
      - /price/P-001?v=1          (v_query=1)
      - legacy path forms where caller encoded '?v=1' inside card_id
        e.g. OP01-001?v=1 or OP01-001V=1
    """
    s = (card_id_raw or "").strip().upper()

    # If caller encoded "?v=1" into the path, it'll arrive as literal text.
    # Extract embedded v first.
    embedded = EMBEDDED_V_RE.search(s)
    embedded_v = int(embedded.group(1)) if embedded else None

    # Prefer explicit query param if provided, else embedded, else 0
    version = int(v_query) if v_query is not None else (embedded_v if embedded_v is not None else 0)
    if version < 0:
        version = 0

    # Remove any embedded query fragments from the base id
    # Examples:
    #   "OP01-001?V=1" -> "OP01-001"
    #   "P-001V=2"     -> "P-001"
    base = re.split(r"[?&]", s, maxsplit=1)[0]
    base = re.sub(r"V=\d+", "", base, flags=re.IGNORECASE).strip()

    # Validate base
    if not (NORMAL_ID_RE.match(base) or PROMO_ID_RE.match(base)):
        raise ValueError(f"Invalid card_id format: {card_id_raw}")

    return base, version


def scrape_prices(base_id: str, version: int):
    """
    base_id: OP01-001 or P-001
    version: 0,1,2,... (index into Limitless prints table)
    """
    formatted = f"{base_id}?v={version}" if version > 0 else base_id
    url = BASE_URL.format(formatted)

    r = requests.get(url, timeout=20)
    r.raise_for_status()
    soup = BeautifulSoup(r.text, "html.parser")

    table = (
        soup.select_one("table.prints-table")
        or soup.select_one("div.card-prints table")
        or soup.select_one("table")
    )

    if not table:
        return {"usd_price": 0.0, "eur_price": 0.0, "usd_url": None, "eur_url": None}

    usd_prices, eur_prices, usd_urls, eur_urls = [], [], [], []

    for row in table.select("tr"):
        if row.find("th"):
            continue

        usd_link = row.select_one("a.card-price.usd")
        eur_link = row.select_one("a.card-price.eur")

        usd_prices.append(parse_price(usd_link.text) if usd_link else 0.0)
        eur_prices.append(parse_price(eur_link.text) if eur_link else 0.0)
        usd_urls.append(usd_link.get("href") if usd_link else None)
        eur_urls.append(eur_link.get("href") if eur_link else None)

    if version >= len(usd_prices):
        version = 0

    return {
        "usd_price": usd_prices[version],
        "eur_price": eur_prices[version],
        "usd_url": usd_urls[version],
        "eur_url": eur_urls[version],
    }


# ------------------------------------------------------
# PRICE ENDPOINT
# ------------------------------------------------------
@app.get("/price/{card_id}")
def get_price(card_id: str, v: int | None = None):
    """
    Preferred usage:
      /price/OP01-001?v=1
      /price/P-001?v=2

    Still supports legacy callers that pass encoded '?v=1' inside the path.
    """
    now = datetime.utcnow()

    try:
        base, version = normalize_card_and_version(card_id, v)
    except ValueError as e:
        # Keep API behavior consistent: return 400-ish info
        return {"card_id": card_id, "error": str(e)}

    # Canonical cache key ensures all callers hit the same cache entry
    cache_key = f"{base}?v={version}" if version > 0 else base

    cached = PRICE_CACHE.get(cache_key)
    if cached and now - cached["timestamp"] < CACHE_TTL:
        return {"card_id": cache_key, "prices": cached["data"], "cached": True}

    prices = scrape_prices(base, version)
    PRICE_CACHE[cache_key] = {"timestamp": now, "data": prices}
    save_cache_to_disk()

    return {"card_id": cache_key, "prices": prices, "cached": False}


# ------------------------------------------------------
# COLLECTR PRICE ENDPOINTS (JSON-BASED)
# ------------------------------------------------------
@app.get("/prices/dons")
def get_dons_prices():
    items = load_collectr_items(DONS_FILE, "don")
    return {
        "type": "don",
        "count": len(items),
        "cached": True,
        "updated_at": file_mtime_iso(DONS_FILE),
        "items": items,
    }


@app.get("/prices/sealed")
def get_sealed_prices():
    items = load_collectr_items(SEALED_FILE, "sealed")
    return {
        "type": "sealed",
        "count": len(items),
        "cached": True,
        "updated_at": file_mtime_iso(SEALED_FILE),
        "items": items,
    }


# ------------------------------------------------------
# HISTORY — CARDS
# ------------------------------------------------------
@app.get("/history/{card_id}")
def get_history(card_id: str, limit: int = 365):
    cid = card_id.replace("?", "").strip()

    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute(
        """
        SELECT date, eur_price, usd_price
        FROM card_history
        WHERE card_id = ?
        ORDER BY date ASC
        LIMIT ?
        """,
        (cid, limit),
    )

    rows = cursor.fetchall()
    conn.close()

    return {
        "type": "card",
        "id": cid,
        "count": len(rows),
        "history": [{"date": d, "eur": eur, "usd": usd} for d, eur, usd in rows],
    }


# ------------------------------------------------------
# HISTORY — DON
# ------------------------------------------------------
@app.get("/history/don/{name}")
def get_don_history(name: str, limit: int = 365):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute(
        """
        SELECT date, eur_price, usd_price
        FROM don_history
        WHERE name = ?
        ORDER BY date ASC
        LIMIT ?
        """,
        (name, limit),
    )

    rows = cursor.fetchall()
    conn.close()

    return {
        "type": "don",
        "name": name,
        "count": len(rows),
        "history": [{"date": d, "eur": eur, "usd": usd} for d, eur, usd in rows],
    }


# ------------------------------------------------------
# HISTORY — SEALED
# ------------------------------------------------------
@app.get("/history/sealed/{name}")
def get_sealed_history(name: str, limit: int = 365):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute(
        """
        SELECT date, eur_price, usd_price
        FROM sealed_history
        WHERE name = ?
        ORDER BY date ASC
        LIMIT ?
        """,
        (name, limit),
    )

    rows = cursor.fetchall()
    conn.close()

    return {
        "type": "sealed",
        "name": name,
        "count": len(rows),
        "history": [{"date": d, "eur": eur, "usd": usd} for d, eur, usd in rows],
    }


# ------------------------------------------------------
# DECKS
# ------------------------------------------------------
@app.get("/decks")
def get_decks():
    if not os.path.exists(DECKS_PATH):
        return {"error": "Deck file not found"}

    with open(DECKS_PATH, "r", encoding="utf-8") as f:
        return json.load(f)


# ------------------------------------------------------
# MAIN
# ------------------------------------------------------
if __name__ == "__main__":
    uvicorn.run("price_api:app", host="0.0.0.0", port=8000, reload=True)
